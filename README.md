<details>
  <summary>LAB 1:</summary>

In this lab, we have to write a C program that calculates the sum of numbers from 1 to a certain number ("n" in my code) and prints the sum. 
Eventually, we must compare the outputs compiled by the GCC compiler and the RISC-V compiler. 


For this task, we are using the Leafpad text editor provided in Linux. 

![leafpad photo](https://github.com/user-attachments/assets/6226066a-c998-4846-85df-aa8cf11f9a42)

<br>

The following is the code to calculate the sum from "1" to "n" in C language.


```c
#include<stdio.h>
int main()
{
  int sum=0, n=100;
  for(int i=1;i<=n;i++)
  {
    sum+=i;
  }
  printf("The sum of numbers from 1 to %d is %d\n", n, sum);
  return 0;
}
```

![leafpad code photo](https://github.com/user-attachments/assets/7e44fd1e-681a-4fae-9a59-a21e5b7ef9ad)

<br>

After the GCC compilation, we get the following output:

![GCC aout photo](https://github.com/user-attachments/assets/00ab46b3-7e86-4709-be5a-abf7f41f9bc3)

<br>

The following photo shows both the screens (the code, and the output generated from the GCC compilation):

![both photo](https://github.com/user-attachments/assets/dad34694-b079-4d0b-909e-5e12d51800b0)

Next, we see the compilation obtained by the RISC-V compiler.

Using O1:

The following command generates the object file, ("sum1ton.o" in my case):

```console
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
![O1 1st tab](https://github.com/user-attachments/assets/568859ae-65f1-4e34-b545-e843150005e9)

Next, to see the assembly-level code contained in the ".o" file, we enter this command:

```console
riscv64-unknown-elf-gcc-objdump -d sum1ton.o
riscv64-unknown-elf-gcc-objdump -d sum1ton.o | less
```

![O1 2nd tab aft](https://github.com/user-attachments/assets/fadf4b6e-6840-470c-9235-af066a5e6ea9)

Using Ofast:

The following command generates the object file, ("sum1ton.o" in my case):

```console
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
![Ofast 1st tab ](https://github.com/user-attachments/assets/c025e3f0-0d47-4a5e-b6e4-8eebb5c43677)

Next, to see the assembly-level code contained in the ".o" file, we enter this command:

```console
riscv64-unknown-elf-gcc-objdump -d sum1ton.o
riscv64-unknown-elf-gcc-objdump -d sum1ton.o | less
```

![Ofast 2nd tab aft](https://github.com/user-attachments/assets/947988a5-9f52-4c27-b3af-ebf0f0447f33)

Now given the outputs generated by using the 2 flags (O1 and Ofast), we can say that less number of instructions were carried on in the Ofast flag.
This can be calculated by simply subtracting the address of the first instruction in the "main" section from the address of the first instruction in the next section ("register_fini" in this scenario).
<br>
<br>
So, on calculating:
<br>
Ofast - Hex(100e0 - 100b0) / 4 = 12 
<br>
O1 - Hex(101c0 - 10184) / 4 = 15

As, 12<15, we can say that less number of instructions were carried on in the Ofast, as compared to O1 flag. 
</details>

<details><summary>LAB 2:</summary>

In this lab we have to use the debug tool in the Spike simulator. It makes debugging a lot easier, as we can actually go through every instruction, and check the values.

Firstly, checking the output received using the command in the previous lab, such that it matches with the output generated by the GCC compiler.

![Q2 1st](https://github.com/user-attachments/assets/9cbd2546-ddd9-4855-b992-332d992a2fe4)

By this we can see the output generated is same, that is 5050.

Now to debug the code, we use the following, 

```console
spike -d pk sum1ton.o
```
Now, we instruct Spike to run the program in such a way, that it reaches the start of the "main" section. It cn be seen starting at the address "100b0". 
This can be done by typing:

```console
until pc 0 100b0
```

On reaching that point, we can see various instructions like "lui a2,Ox1", and "lui a0,Ox21", etc.
By this we can observe the value of a2, changes from "0x0000000000000000" to "0x0000000000001000", and value of a0 changes from "0x0000000000000001" to "0x0000000000021000". 
Also the value of the stack pointer following the instruction "addi sp,sp,-16" changes from "0x0000003ffffffb50" to "0x0000003ffffffb40".
The stack pointer is being decremented by the value 16, (or being incremented by -16 in Hex). 

![Q2 2nd](https://github.com/user-attachments/assets/299df7ea-2a92-46ad-aa76-81db53eee1ed)
</details>

<details>
  <summary>LAB 3:</summary>

  In this lab, we have to first identify various RISC-V instruction type (R, I, S, B, U, J) and exact 32-bit instruction code in the instruction type format for the given RISC-V instructions.

  ```
 ADD r10, r11, r12
 SUB r12, r10, r11
 AND r11, r10, r12
 OR r8, r11, r5
 XOR r8, r10, r4
 SLT r00, r1, r4
 ADDI r02, r2, 5
 SW r2, r0, 4
 SRL r06, r01, r1
 BNE r0, r0, 20
 BEQ r0, r0, 15
 LW r03, r01, 2
 SLL r05, r01, r1
  ```
  Here are the basic formats for the given instruction types (R, I, S, B, U, J):
  
  1. R-Type (Register)
   * Purpose: Used for arithmetic and logical operations where both operands are registers.
   * Examples: ADD, SUB, AND, OR, XOR, SLT

<br>

  2. I-Type (Immediate)
   * Purpose: Used for arithmetic operations with an immediate value, load instructions, and other operations.
   * Examples: ADDI, LW, SRLI

<br>

  3. S-Type (Store)
   * Purpose: Used for storing instructions, which write data from a register to memory.
   * Examples: SW

<br>

  4. B-Type (Branch)
   * Purpose: Used for conditional branch instructions.
   * Examples: BEQ, BNE
     
<br>

  5. U-Type (Upper Immediate)
   * Purpose: Used for instructions that operate with a 20-bit immediate value, usually for loading a high-order address part.
   * Examples: LUI (Load Upper Immediate), AUIPC (Add Upper Immediate to PC)

<br>

  6. J-Type (Jump)
   * Purpose: Used for jump instructions that transfer control to a target address.
   * Examples: JAL (Jump and Link)
<br>

![instr2](https://github.com/user-attachments/assets/4abeb1c5-48ba-435d-8419-d31b49aa6035)

1. ADD r10, r11, r12
   
    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h00B5A033
      *  Binary: 0000000 01100 01011 000 01010 0110011
    * opcode: 0110011 (7 bits)
    * rd: 01010 (r10) (5 bits)
    * funct3: 000 (3 bits)
    * rs1: 01011 (r11) (5 bits)
    * rs2: 01100 (r12) (5 bits)
    * funct7: 0000000 (7 bits)

3. SUB r12, r10, r11

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h40B5C033
      * Binary: 0100000 01011 01010 000 01100 0110011
    * opcode: 0110011 (7 bits)
    * rd: 01100 (r12) (5 bits)
    * funct3: 000 (3 bits)
    * rs1: 01010 (r10) (5 bits)
    * rs2: 01011 (r11) (5 bits)
    * funct7: 0100000 (7 bits)

4. AND r11, r10, r12

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h00C5B033
      *  Binary: 0000000 01100 01010 111 01011 0110011
    * opcode: 0110011 (7 bits)
    * rd: 01011 (r11) (5 bits)
    * funct3: 111 (3 bits)
    * rs1: 01010 (r10) (5 bits)
    * rs2: 01100 (r12) (5 bits)
    * funct7: 0000000 (7 bits)

5. OR r8, r11, r5

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h0055A833
      *  Binary: 0000000 00101 01011 110 01000 0110011
    * opcode: 0110011 (7 bits)
    * rd: 01000 (r8) (5 bits)
    * funct3: 110 (3 bits)
    * rs1: 01011 (r11) (5 bits)
    * rs2: 00101 (r5) (5 bits)
    * funct7: 0000000 (7 bits)

6. XOR r8, r10, r4

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h0045A833
      *  Binary: 0000000 00100 01010 100 01000 0110011
    * opcode: 0110011 (7 bits)
    * rd: 01000 (r8) (5 bits)
    * funct3: 100 (3 bits)
    * rs1: 01010 (r10) (5 bits)
    * rs2: 00100 (r4) (5 bits)
    * funct7: 0000000 (7 bits)

7. SLT r00, r1, r4

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h00408033
      *  Binary: 0000000 00100 00001 010 00000 0110011
    * opcode: 0110011 (7 bits)
    * rd: 00000 (r0) (5 bits)
    * funct3: 010 (3 bits)
    * rs1: 00001 (r1) (5 bits)
    * rs2: 00100 (r4) (5 bits)
    * funct7: 0000000 (7 bits)

8. ADDI r02, r2, 5

    * Instruction Type: I-Type
    * 32-bit Pattern:
      *  Hex: 32'h00510013
      *  Binary: 000000000101 00010 000 00010 0010011
    * opcode: 0010011 (7 bits)
    * rd: 00010 (r2) (5 bits)
    * funct3: 000 (3 bits)
    * rs1: 00010 (r2) (5 bits)
    * imm: 000000000101 (12 bits) - Immediate value 5

9. SW r2, r0, 4

    * Instruction Type: S-Type
    * 32-bit Pattern:
      *  Hex: 32'h00402023
      *  Binary: 0000000 00010 00000 010 00100 0100011
    * opcode: 0100011 (7 bits)
    * imm[11:5]: 0000000 (7 bits) - Part of the immediate value
    * rs2: 00010 (r2) (5 bits)
    * rs1: 00000 (r0) (5 bits)
    * funct3: 010 (3 bits)
    * imm[4:0]: 00100 (5 bits) - Part of the immediate value 4

10. SRL r06, r01, r1

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h00129033
      *  Binary: 0000000 00001 00001 101 00110 0110011
    * opcode: 0110011 (7 bits)
    * rd: 00110 (r6) (5 bits)
    * funct3: 101 (3 bits)
    * rs1: 00001 (r1) (5 bits)
    * rs2: 00001 (r1) (5 bits)
    * funct7: 0000000 (7 bits)

11. BNE r0, r0, 20

    * Instruction Type: B-Type
    * 32-bit Pattern:
      *  Hex: 32'h01400063
      *  Binary: 0 000001 00000 00000 001 0100 0 1100011
    * opcode: 1100011 (7 bits)
    * imm[12]: 0 (1 bit) - Part of the immediate value
    * imm[10:5]: 000001 (6 bits) - Part of the immediate value
    * rs2: 00000 (r0) (5 bits)
    * rs1: 00000 (r0) (5 bits)
    * funct3: 001 (3 bits)
    * imm[4:1]: 0100 (4 bits) - Part of the immediate value
    * imm[11]: 0 (1 bit) - Part of the immediate value 20

12. BEQ r0, r0, 15

    * Instruction Type: B-Type
    * 32-bit Pattern:
      *  Hex: 32'h00F00063
      *  Binary: 0 000000 00000 00000 000 1111 0 1100011
    * opcode: 1100011 (7 bits)
    * imm[12]: 0 (1 bit) - Part of the immediate value
    * imm[10:5]: 000000 (6 bits) - Part of the immediate value
    * rs2: 00000 (r0) (5 bits)
    * rs1: 00000 (r0) (5 bits)
    * funct3: 000 (3 bits)
    * imm[4:1]: 1111 (4 bits) - Part of the immediate value
    * imm[11]: 0 (1 bit) - Part of the immediate value 15

13. LW r03, r01, 2

    * Instruction Type: I-Type
    * 32-bit Pattern:
      *  Hex: 32'h00212083
      *  Binary: 000000000010 00001 010 00011 0000011
    * opcode: 0000011 (7 bits)
    * rd: 00011 (r3) (5 bits)
    * funct3: 010 (3 bits)
    * rs1: 00001 (r1) (5 bits)
    * imm: 000000000010 (12 bits) - Immediate value 2

14. SLL r05, r01, r1

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h00109033
      *  Binary: 0000000 00001 00001 001 00101 0110011
    * opcode: 0110011 (7 bits)
    * rd: 00101 (r5) (5 bits)
    * funct3: 001 (3 bits)
    * rs1: 00001 (r1) (5 bits)
    * rs2: 00001 (r1) (5 bits)
    * funct7: 0000000 (7 bits)
</details>

<details><summary>LAB 4:</summary>

In this lab, we have to use the RISC-V code netlist and testbench for functional simulation experiments. We also have to create waveforms using gtkwave and attach snapshots.

<br>

The instructions implemented are:

![1_instr](https://github.com/user-attachments/assets/ac58c154-5f86-4897-96e6-ffeded25f727)

Below, are the given Standard ISA and the Hardcode ISA:

|Instruction	   |Standard RISC-V ISA |Hardcoded ISA|
|----------------|--------------------|-------------|
|ADD R6, R2, R1  |	32'h00110333 	    |32'h02208300 |
|SUB R7, R1, R2  |	32'h402083b3 	    |32'h02209380 |
|AND R8, R1, R3  |	32'h0030f433 	    |32'h0230a400 |
|OR R9, R2, R5 	 |  32'h005164b3 	    |32'h02513480 |
|XOR R10, R1, R4 |	32'h0040c533 	    |32'h0240c500 |
|SLT R1, R2, R4  |	32'h0045a0b3 	    |32'h02415580 |
|ADDI R12, R4, 5 | 	32'h004120b3 	    |32'h00520600 |
|BEQ R0, R0, 15  |	32'h00000f63 	    |32'h00f00002 |
|SW R3, R1, 2 	 |  32'h0030a123 	    |32'h00209181 |
|LW R13, R1, 2 	 |  32'h0020a683 	    |32'h00208681 |
|SRL R16, R14, R2| 	32'h0030a123 	    |32'h00271803 |
|SLL R15, R1, R2 |	32'h002097b3 	    |32'h00208783 |

We get the following result, after using the commands mentioned:

<br>

![Out_earlier](https://github.com/user-attachments/assets/1d203789-8830-481f-a2d8-d76bb3de10b6)

The Hardcoded instructions gave the following waveforms:

ADD r6, r2, r1

![1_1](https://github.com/user-attachments/assets/449f9a42-b696-4c71-a646-2d1414af6922)


SUB r7, r1, r2

![1_2](https://github.com/user-attachments/assets/db7d638a-feeb-48ca-aeba-001fe0a5f643)

AND r8, r1, r3

![1_3](https://github.com/user-attachments/assets/eb5f26c2-43fb-4944-b77b-395ceff23fb8)

OR r9, r2, r5 

![1_4](https://github.com/user-attachments/assets/7521e7ce-b578-4828-bbf1-a6a616de11ac)

XOR r10, r1, r4

![1_5](https://github.com/user-attachments/assets/cf481e07-c839-4e6f-af84-b04c8f4d80b0)

SLT r11, r2, r4 

![1_6](https://github.com/user-attachments/assets/986565b8-96ff-4780-af55-eb633db8e285)

ADDI r12, r4, 5 

![1_7](https://github.com/user-attachments/assets/2494d60e-6991-4c85-82aa-d78aa360247f)

SW r3, r1, 2

![1_8](https://github.com/user-attachments/assets/e8f73cae-0a7b-493b-9235-0d4865f75a13)

LW r13, r1, 2

![1_9](https://github.com/user-attachments/assets/bf2226e9-08b1-4633-8090-01f13beb1be3)

BEQ r0, r0, 15 

![1_10](https://github.com/user-attachments/assets/33d6977b-e176-4afd-809e-5c219fd0bc04)

ADD r14, r2, r2 

![1_11](https://github.com/user-attachments/assets/d961d468-c0b9-48cb-881c-0e8b2331d36c)

Final Output:

![1_final](https://github.com/user-attachments/assets/8bfca5e7-641d-4bbc-ac95-237632a87370)

Observation: We observe a variation between bit pattern of RISCV code and hardcoded ISA.

</details>

<details><summary>LAB 5:</summary>
  In this lab, we had to write a C code and compile it with the GCC compiler and RISCV-GCC compiler. After compiling, we have to check whether both the shown outputs are identical.

  <br>

  For this purpose, I chose to write a code to calculate divisors of a number and give prime factorization, as this is one of the codes that I have encountered a lot while doing competitive programming.

  <br>

  Rather than having a linear time complexity, we will be using a square-root time complexity (for optimization purposes).

  Code:

  ```c
  #include<stdio.h>
  #include<math.h>
  int main()
  {
    //this is an optimised way to calculate the divisors of a number
    //rather than linear time, we are square root time complexity algorithm
    int num;
    printf("Please enter the number of your choice except 0: ");
    scanf("%d", &num);
    printf("Divisors of %d are: ",num);
    int c=0;
    for(int i=1;i*i<=num;i++)
    {
      if(num%i==0)
      {
        printf("%d ",i);
      }
      c=i;
    }
    for(int i=c;i>0;i--)
    {
      if(num%i==0 && i!=(num/i))
      {
        printf("%d ",num/i);
      }
    }
    printf("\n");
    printf("The prime factorization of %d is: ", num);
    if(num==1)
    {
      printf("N/A\n");
    }
    else
    {
      while(num%2==0)
      {
        printf("%d ",2);
        num/=2;
      }
      for(int i=3;i*i<=num;i+=2)
      {
        while(num%i==0)
        {
          printf("%d ",i);
          num/=i;
        }
      }
      if(num>1)
      {
        printf("%d ",num);
      }
      printf("\n");
    }
    return 0;
  }
```

Output obtained by using GCC compiler:

![gcc output](https://github.com/user-attachments/assets/6be9b40e-75a7-4e14-a7c1-ffd68a9f4faa)

Output obtained by using RISCV-GCC compiler:

![riscv output](https://github.com/user-attachments/assets/fc294b67-0dbf-4b9f-a774-8a88508154db)

Observation:

We can see that, the output obtained in both cases is the same.
  
</details>

<details>
  <summary>LAB 6:</summary>

  In this lab, we have to build a 5-stage pipelined RISC-V processor by following the detailed lab lectures on the VSDIAT platform.
  
  In this, we also have to use a unique clock signal name. The name should be constructed using the prefix "clk_", followed by the prefix of our name. In my case, the clock's name is "clk_adi".
  
  <details>
  <summary>Day 4:</summary>
  For the given code, the output waveforms and the block diagrams are as follows:
    
  Block Diagram:
    
  ![4_block](https://github.com/user-attachments/assets/0b01ae9d-f0e3-4d7e-b3bc-c475405f4ddb)

  Waveform:
  * CLK named as "clk_adi":
    ![4_clk](https://github.com/user-attachments/assets/7a1ec691-fa1b-42e3-b2b4-6ff7c572b78b)
  * Reset:
    ![4_reset](https://github.com/user-attachments/assets/0f9c0e7c-dc76-41cf-8a2f-728509ddafe4)
  * Final waveform:
    ![4_final](https://github.com/user-attachments/assets/8b39a43b-3e3d-4d82-9a26-25944623aae9)

  TestBench:
  
  To verify the correctness of the code, we use a testbench to check it during the first five cycles.
  ![4_sim](https://github.com/user-attachments/assets/4d3b4637-d40a-4196-af5c-213fd78f2b47)

  </details>
  
  <details>
    <summary>Day 5:</summary>
    We have observed that we might get logical errors, due to some interdependencies of the values. For this, pipelining of the CPU core is done, which allows easy retiming and reduces discrepancies to a certain extent. Also, pipelining provides faster computation.

Below are the diagrams and the various parts of the code:

![5_1](https://github.com/user-attachments/assets/a0006833-9b3b-473e-94af-dc0561914493)
    
![5_2](https://github.com/user-attachments/assets/2e3ad5dd-0edc-475e-945a-72ab766cbf99)
    
![5_3](https://github.com/user-attachments/assets/05efbf3b-0ee2-4c5c-b4a9-116752d6ce97)
    
![5_4](https://github.com/user-attachments/assets/bcd37ed8-ea18-4156-8031-a592c43d9afa)
    
![5_5](https://github.com/user-attachments/assets/3a6c86bc-f66b-440e-99a7-bc2d521013da)
    
![5_6](https://github.com/user-attachments/assets/08558b71-7ddd-4853-ad3d-7e4423a18906)
    
![5_7](https://github.com/user-attachments/assets/4531c1d7-25ff-4309-b427-c4cfaa45b8bd)
    
![5_8](https://github.com/user-attachments/assets/27069faa-3d75-403a-b695-6988abae79e9)
    
![5_9](https://github.com/user-attachments/assets/7101e746-b1f3-406f-b8cb-c283e541f142)
    
![5_10](https://github.com/user-attachments/assets/3a7457ea-09c7-432a-9de6-b06e3e5c500a)
    
![5_11](https://github.com/user-attachments/assets/2c85858d-85e5-4e79-bc22-3c09e5edbab6)
    
![5_12](https://github.com/user-attachments/assets/5bd2fa2a-afbd-4b2a-b23c-e923bcaae3d9)

Result:

* Block Diagram :

  ![5_block](https://github.com/user-attachments/assets/939aa4d0-aec0-4541-8815-6e5bbe96664a)

* Viz Table : We can see that value of reg 14 reaches 45 after 54 cycles.

  ![5_viz](https://github.com/user-attachments/assets/ae94c074-6515-46e5-bda6-c06ab03aa536)

* Waveform:
  * CLK named as clk_adi:

    ![5_clk](https://github.com/user-attachments/assets/6473761f-9347-4f70-b8cc-4159fe318472)

  * Reset waveform :

    ![5_reset](https://github.com/user-attachments/assets/057cfe2b-9eb1-4569-b253-9b80c838f7b5)

  * Final result waveform showing gradual increase:

    ![5_xreg](https://github.com/user-attachments/assets/ab06991f-499c-41f3-8826-a963f10c97b5)

Simulation Status :

![5_sim](https://github.com/user-attachments/assets/725ff7e0-be79-4b95-b6b7-62e05fb596cc)

  </details>
</details>
