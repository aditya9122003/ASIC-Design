<details>
  <summary>LAB 1:</summary>

In this lab, we have to write a C program that calculates the sum of numbers from 1 to a certain number ("n" in my code) and prints the sum. 
Eventually, we must compare the outputs compiled by the GCC compiler and the RISC-V compiler. 


For this task, we are using the Leafpad text editor provided in Linux. 

![leafpad photo](https://github.com/user-attachments/assets/6226066a-c998-4846-85df-aa8cf11f9a42)

<br>

The following is the code to calculate the sum from "1" to "n" in C language.


```c
#include<stdio.h>
int main()
{
  int sum=0, n=100;
  for(int i=1;i<=n;i++)
  {
    sum+=i;
  }
  printf("The sum of numbers from 1 to %d is %d\n", n, sum);
  return 0;
}
```

![leafpad code photo](https://github.com/user-attachments/assets/7e44fd1e-681a-4fae-9a59-a21e5b7ef9ad)

<br>

After the GCC compilation, we get the following output:

![GCC aout photo](https://github.com/user-attachments/assets/00ab46b3-7e86-4709-be5a-abf7f41f9bc3)

<br>

The following photo shows both the screens (the code, and the output generated from the GCC compilation):

![both photo](https://github.com/user-attachments/assets/dad34694-b079-4d0b-909e-5e12d51800b0)

Next, we see the compilation obtained by the RISC-V compiler.

Using O1:

The following command generates the object file, ("sum1ton.o" in my case):

```console
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
![O1 1st tab](https://github.com/user-attachments/assets/568859ae-65f1-4e34-b545-e843150005e9)

Next, to see the assembly-level code contained in the ".o" file, we enter this command:

```console
riscv64-unknown-elf-gcc-objdump -d sum1ton.o
riscv64-unknown-elf-gcc-objdump -d sum1ton.o | less
```

![O1 2nd tab aft](https://github.com/user-attachments/assets/fadf4b6e-6840-470c-9235-af066a5e6ea9)

Using Ofast:

The following command generates the object file, ("sum1ton.o" in my case):

```console
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
![Ofast 1st tab ](https://github.com/user-attachments/assets/c025e3f0-0d47-4a5e-b6e4-8eebb5c43677)

Next, to see the assembly-level code contained in the ".o" file, we enter this command:

```console
riscv64-unknown-elf-gcc-objdump -d sum1ton.o
riscv64-unknown-elf-gcc-objdump -d sum1ton.o | less
```

![Ofast 2nd tab aft](https://github.com/user-attachments/assets/947988a5-9f52-4c27-b3af-ebf0f0447f33)

Now given the outputs generated by using the 2 flags (O1 and Ofast), we can say that less number of instructions were carried on in the Ofast flag.
This can be calculated by simply subtracting the address of the first instruction in the "main" section from the address of the first instruction in the next section ("register_fini" in this scenario).
<br>
<br>
So, on calculating:
<br>
Ofast - Hex(100e0 - 100b0) / 4 = 12 
<br>
O1 - Hex(101c0 - 10184) / 4 = 15

As, 12<15, we can say that less number of instructions were carried on in the Ofast, as compared to O1 flag. 
</details>

<details><summary>LAB 2:</summary>

In this lab we have to use the debug tool in the Spike simulator. It makes debugging a lot easier, as we can actually go through every instruction, and check the values.

Firstly, checking the output received using the command in the previous lab, such that it matches with the output generated by the GCC compiler.

![Q2 1st](https://github.com/user-attachments/assets/9cbd2546-ddd9-4855-b992-332d992a2fe4)

By this we can see the output generated is same, that is 5050.

Now to debug the code, we use the following, 

```console
spike -d pk sum1ton.o
```
Now, we instruct Spike to run the program in such a way, that it reaches the start of the "main" section. It cn be seen starting at the address "100b0". 
This can be done by typing:

```console
until pc 0 100b0
```

On reaching that point, we can see various instructions like "lui a2,Ox1", and "lui a0,Ox21", etc.
By this we can observe the value of a2, changes from "0x0000000000000000" to "0x0000000000001000", and value of a0 changes from "0x0000000000000001" to "0x0000000000021000". 
Also the value of the stack pointer following the instruction "addi sp,sp,-16" changes from "0x0000003ffffffb50" to "0x0000003ffffffb40".
The stack pointer is being decremented by the value 16, (or being incremented by -16 in Hex). 

![Q2 2nd](https://github.com/user-attachments/assets/299df7ea-2a92-46ad-aa76-81db53eee1ed)
</details>

<details>
  <summary>LAB 3:</summary>

  In this lab, we have to first identify various RISC-V instruction type (R, I, S, B, U, J) and exact 32-bit instruction code in the instruction type format for the given RISC-V instructions.

  ```
 ADD r10, r11, r12
 SUB r12, r10, r11
 AND r11, r10, r12
 OR r8, r11, r5
 XOR r8, r10, r4
 SLT r00, r1, r4
 ADDI r02, r2, 5
 SW r2, r0, 4
 SRL r06, r01, r1
 BNE r0, r0, 20
 BEQ r0, r0, 15
 LW r03, r01, 2
 SLL r05, r01, r1
  ```
  Here are the basic formats for the given instruction types (R, I, S, B, U, J):
  
  1. R-Type (Register)
   * Purpose: Used for arithmetic and logical operations where both operands are registers.
   * Examples: ADD, SUB, AND, OR, XOR, SLT

<br>

  2. I-Type (Immediate)
   * Purpose: Used for arithmetic operations with an immediate value, load instructions, and other operations.
   * Examples: ADDI, LW, SRLI

<br>

  3. S-Type (Store)
   * Purpose: Used for storing instructions, which write data from a register to memory.
   * Examples: SW

<br>

  4. B-Type (Branch)
   * Purpose: Used for conditional branch instructions.
   * Examples: BEQ, BNE
     
<br>

  5. U-Type (Upper Immediate)
   * Purpose: Used for instructions that operate with a 20-bit immediate value, usually for loading a high-order address part.
   * Examples: LUI (Load Upper Immediate), AUIPC (Add Upper Immediate to PC)

<br>

  6. J-Type (Jump)
   * Purpose: Used for jump instructions that transfer control to a target address.
   * Examples: JAL (Jump and Link)
<br>

![instr2](https://github.com/user-attachments/assets/4abeb1c5-48ba-435d-8419-d31b49aa6035)

1. ADD r10, r11, r12
   
    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h00B5A033
      *  Binary: 0000000 01100 01011 000 01010 0110011
    * opcode: 0110011 (7 bits)
    * rd: 01010 (r10) (5 bits)
    * funct3: 000 (3 bits)
    * rs1: 01011 (r11) (5 bits)
    * rs2: 01100 (r12) (5 bits)
    * funct7: 0000000 (7 bits)

3. SUB r12, r10, r11

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h40B5C033
      * Binary: 0100000 01011 01010 000 01100 0110011
    * opcode: 0110011 (7 bits)
    * rd: 01100 (r12) (5 bits)
    * funct3: 000 (3 bits)
    * rs1: 01010 (r10) (5 bits)
    * rs2: 01011 (r11) (5 bits)
    * funct7: 0100000 (7 bits)

4. AND r11, r10, r12

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h00C5B033
      *  Binary: 0000000 01100 01010 111 01011 0110011
    * opcode: 0110011 (7 bits)
    * rd: 01011 (r11) (5 bits)
    * funct3: 111 (3 bits)
    * rs1: 01010 (r10) (5 bits)
    * rs2: 01100 (r12) (5 bits)
    * funct7: 0000000 (7 bits)

5. OR r8, r11, r5

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h0055A833
      *  Binary: 0000000 00101 01011 110 01000 0110011
    * opcode: 0110011 (7 bits)
    * rd: 01000 (r8) (5 bits)
    * funct3: 110 (3 bits)
    * rs1: 01011 (r11) (5 bits)
    * rs2: 00101 (r5) (5 bits)
    * funct7: 0000000 (7 bits)

6. XOR r8, r10, r4

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h0045A833
      *  Binary: 0000000 00100 01010 100 01000 0110011
    * opcode: 0110011 (7 bits)
    * rd: 01000 (r8) (5 bits)
    * funct3: 100 (3 bits)
    * rs1: 01010 (r10) (5 bits)
    * rs2: 00100 (r4) (5 bits)
    * funct7: 0000000 (7 bits)

7. SLT r00, r1, r4

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h00408033
      *  Binary: 0000000 00100 00001 010 00000 0110011
    * opcode: 0110011 (7 bits)
    * rd: 00000 (r0) (5 bits)
    * funct3: 010 (3 bits)
    * rs1: 00001 (r1) (5 bits)
    * rs2: 00100 (r4) (5 bits)
    * funct7: 0000000 (7 bits)

8. ADDI r02, r2, 5

    * Instruction Type: I-Type
    * 32-bit Pattern:
      *  Hex: 32'h00510013
      *  Binary: 000000000101 00010 000 00010 0010011
    * opcode: 0010011 (7 bits)
    * rd: 00010 (r2) (5 bits)
    * funct3: 000 (3 bits)
    * rs1: 00010 (r2) (5 bits)
    * imm: 000000000101 (12 bits) - Immediate value 5

9. SW r2, r0, 4

    * Instruction Type: S-Type
    * 32-bit Pattern:
      *  Hex: 32'h00402023
      *  Binary: 0000000 00010 00000 010 00100 0100011
    * opcode: 0100011 (7 bits)
    * imm[11:5]: 0000000 (7 bits) - Part of the immediate value
    * rs2: 00010 (r2) (5 bits)
    * rs1: 00000 (r0) (5 bits)
    * funct3: 010 (3 bits)
    * imm[4:0]: 00100 (5 bits) - Part of the immediate value 4

10. SRL r06, r01, r1

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h00129033
      *  Binary: 0000000 00001 00001 101 00110 0110011
    * opcode: 0110011 (7 bits)
    * rd: 00110 (r6) (5 bits)
    * funct3: 101 (3 bits)
    * rs1: 00001 (r1) (5 bits)
    * rs2: 00001 (r1) (5 bits)
    * funct7: 0000000 (7 bits)

11. BNE r0, r0, 20

    * Instruction Type: B-Type
    * 32-bit Pattern:
      *  Hex: 32'h01400063
      *  Binary: 0 000001 00000 00000 001 0100 0 1100011
    * opcode: 1100011 (7 bits)
    * imm[12]: 0 (1 bit) - Part of the immediate value
    * imm[10:5]: 000001 (6 bits) - Part of the immediate value
    * rs2: 00000 (r0) (5 bits)
    * rs1: 00000 (r0) (5 bits)
    * funct3: 001 (3 bits)
    * imm[4:1]: 0100 (4 bits) - Part of the immediate value
    * imm[11]: 0 (1 bit) - Part of the immediate value 20

12. BEQ r0, r0, 15

    * Instruction Type: B-Type
    * 32-bit Pattern:
      *  Hex: 32'h00F00063
      *  Binary: 0 000000 00000 00000 000 1111 0 1100011
    * opcode: 1100011 (7 bits)
    * imm[12]: 0 (1 bit) - Part of the immediate value
    * imm[10:5]: 000000 (6 bits) - Part of the immediate value
    * rs2: 00000 (r0) (5 bits)
    * rs1: 00000 (r0) (5 bits)
    * funct3: 000 (3 bits)
    * imm[4:1]: 1111 (4 bits) - Part of the immediate value
    * imm[11]: 0 (1 bit) - Part of the immediate value 15

13. LW r03, r01, 2

    * Instruction Type: I-Type
    * 32-bit Pattern:
      *  Hex: 32'h00212083
      *  Binary: 000000000010 00001 010 00011 0000011
    * opcode: 0000011 (7 bits)
    * rd: 00011 (r3) (5 bits)
    * funct3: 010 (3 bits)
    * rs1: 00001 (r1) (5 bits)
    * imm: 000000000010 (12 bits) - Immediate value 2

14. SLL r05, r01, r1

    * Instruction Type: R-Type
    * 32-bit Pattern:
      *  Hex: 32'h00109033
      *  Binary: 0000000 00001 00001 001 00101 0110011
    * opcode: 0110011 (7 bits)
    * rd: 00101 (r5) (5 bits)
    * funct3: 001 (3 bits)
    * rs1: 00001 (r1) (5 bits)
    * rs2: 00001 (r1) (5 bits)
    * funct7: 0000000 (7 bits)
</details>

<details><summary>LAB 4:</summary>

In this lab, we have to use the RISC-V code netlist and testbench for functional simulation experiments. We also have to create waveforms using gtkwave and attach snapshots.

<br>

The instructions implemented are:

![1_instr](https://github.com/user-attachments/assets/ac58c154-5f86-4897-96e6-ffeded25f727)

Below, are the given Standard ISA and the Hardcode ISA:

|Instruction	   |Standard RISC-V ISA |Hardcoded ISA|
|----------------|--------------------|-------------|
|ADD R6, R2, R1  |	32'h00110333 	    |32'h02208300 |
|SUB R7, R1, R2  |	32'h402083b3 	    |32'h02209380 |
|AND R8, R1, R3  |	32'h0030f433 	    |32'h0230a400 |
|OR R9, R2, R5 	 |  32'h005164b3 	    |32'h02513480 |
|XOR R10, R1, R4 |	32'h0040c533 	    |32'h0240c500 |
|SLT R1, R2, R4  |	32'h0045a0b3 	    |32'h02415580 |
|ADDI R12, R4, 5 | 	32'h004120b3 	    |32'h00520600 |
|BEQ R0, R0, 15  |	32'h00000f63 	    |32'h00f00002 |
|SW R3, R1, 2 	 |  32'h0030a123 	    |32'h00209181 |
|LW R13, R1, 2 	 |  32'h0020a683 	    |32'h00208681 |
|SRL R16, R14, R2| 	32'h0030a123 	    |32'h00271803 |
|SLL R15, R1, R2 |	32'h002097b3 	    |32'h00208783 |

We get the following result, after using the commands mentioned:

<br>

![Out_earlier](https://github.com/user-attachments/assets/1d203789-8830-481f-a2d8-d76bb3de10b6)

The Hardcoded instructions gave the following waveforms:

ADD r6, r2, r1

![1_1](https://github.com/user-attachments/assets/449f9a42-b696-4c71-a646-2d1414af6922)


SUB r7, r1, r2

![1_2](https://github.com/user-attachments/assets/db7d638a-feeb-48ca-aeba-001fe0a5f643)

AND r8, r1, r3

![1_3](https://github.com/user-attachments/assets/eb5f26c2-43fb-4944-b77b-395ceff23fb8)

OR r9, r2, r5 

![1_4](https://github.com/user-attachments/assets/7521e7ce-b578-4828-bbf1-a6a616de11ac)

XOR r10, r1, r4

![1_5](https://github.com/user-attachments/assets/cf481e07-c839-4e6f-af84-b04c8f4d80b0)

SLT r11, r2, r4 

![1_6](https://github.com/user-attachments/assets/986565b8-96ff-4780-af55-eb633db8e285)

ADDI r12, r4, 5 

![1_7](https://github.com/user-attachments/assets/2494d60e-6991-4c85-82aa-d78aa360247f)

SW r3, r1, 2

![1_8](https://github.com/user-attachments/assets/e8f73cae-0a7b-493b-9235-0d4865f75a13)

LW r13, r1, 2

![1_9](https://github.com/user-attachments/assets/bf2226e9-08b1-4633-8090-01f13beb1be3)

BEQ r0, r0, 15 

![1_10](https://github.com/user-attachments/assets/33d6977b-e176-4afd-809e-5c219fd0bc04)

ADD r14, r2, r2 

![1_11](https://github.com/user-attachments/assets/d961d468-c0b9-48cb-881c-0e8b2331d36c)

Final Output:

![1_final](https://github.com/user-attachments/assets/8bfca5e7-641d-4bbc-ac95-237632a87370)

Observation: We observe a variation between bit pattern of RISCV code and hardcoded ISA.

</details>

<details><summary>LAB 5:</summary>
  In this lab, we had to write a C code and compile it with the GCC compiler and RISCV-GCC compiler. After compiling, we have to check whether both the shown outputs are identical.

  <br>

  For this purpose, I chose to write a code to calculate divisors of a number and give prime factorization, as this is one of the codes that I have encountered a lot while doing competitive programming.

  <br>

  Rather than having a linear time complexity, we will be using a square-root time complexity (for optimization purposes).

  Code:

  ```c
  #include<stdio.h>
  #include<math.h>
  int main()
  {
    //this is an optimised way to calculate the divisors of a number
    //rather than linear time, we are square root time complexity algorithm
    int num;
    printf("Please enter the number of your choice except 0: ");
    scanf("%d", &num);
    printf("Divisors of %d are: ",num);
    int c=0;
    for(int i=1;i*i<=num;i++)
    {
      if(num%i==0)
      {
        printf("%d ",i);
      }
      c=i;
    }
    for(int i=c;i>0;i--)
    {
      if(num%i==0 && i!=(num/i))
      {
        printf("%d ",num/i);
      }
    }
    printf("\n");
    printf("The prime factorization of %d is: ", num);
    if(num==1)
    {
      printf("N/A\n");
    }
    else
    {
      while(num%2==0)
      {
        printf("%d ",2);
        num/=2;
      }
      for(int i=3;i*i<=num;i+=2)
      {
        while(num%i==0)
        {
          printf("%d ",i);
          num/=i;
        }
      }
      if(num>1)
      {
        printf("%d ",num);
      }
      printf("\n");
    }
    return 0;
  }
```

Output obtained by using GCC compiler:

![gcc output](https://github.com/user-attachments/assets/6be9b40e-75a7-4e14-a7c1-ffd68a9f4faa)

Output obtained by using RISCV-GCC compiler:

![riscv output](https://github.com/user-attachments/assets/fc294b67-0dbf-4b9f-a774-8a88508154db)

Observation:

We can see that, the output obtained in both cases is the same.
  
</details>

<details>
  <summary>LAB 6:</summary>

  In this lab, we have to build a 5-stage pipelined RISC-V processor by following the detailed lab lectures on the VSDIAT platform.
  
  In this, we also have to use a unique clock signal name. The name should be constructed using the prefix "clk_", followed by the prefix of our name. In my case, the clock's name is "clk_adi".
  
  <details>
  <summary>Day 4:</summary>
  For the given code, the output waveforms and the block diagrams are as follows:
    
  Block Diagram:
    
  ![4_block](https://github.com/user-attachments/assets/0b01ae9d-f0e3-4d7e-b3bc-c475405f4ddb)

  Waveform:
  * CLK named as "clk_adi":
    ![4_clk](https://github.com/user-attachments/assets/7a1ec691-fa1b-42e3-b2b4-6ff7c572b78b)
  * Reset:
    ![4_reset](https://github.com/user-attachments/assets/0f9c0e7c-dc76-41cf-8a2f-728509ddafe4)
  * Final waveform:
    ![4_final](https://github.com/user-attachments/assets/8b39a43b-3e3d-4d82-9a26-25944623aae9)

  TestBench:
  
  To verify the correctness of the code, we use a testbench to check it during the first five cycles.
  ![4_sim](https://github.com/user-attachments/assets/4d3b4637-d40a-4196-af5c-213fd78f2b47)

  </details>
  
  <details>
    <summary>Day 5:</summary>
    We have observed that we might get logical errors, due to some interdependencies of the values. For this, pipelining of the CPU core is done, which allows easy retiming and reduces discrepancies to a certain extent. Also, pipelining provides faster computation.

Below are the diagrams and the various parts of the code:

![5_1](https://github.com/user-attachments/assets/a0006833-9b3b-473e-94af-dc0561914493)
    
![5_2](https://github.com/user-attachments/assets/2e3ad5dd-0edc-475e-945a-72ab766cbf99)
    
![5_3](https://github.com/user-attachments/assets/05efbf3b-0ee2-4c5c-b4a9-116752d6ce97)
    
![5_4](https://github.com/user-attachments/assets/bcd37ed8-ea18-4156-8031-a592c43d9afa)
    
![5_5](https://github.com/user-attachments/assets/3a6c86bc-f66b-440e-99a7-bc2d521013da)
    
![5_6](https://github.com/user-attachments/assets/08558b71-7ddd-4853-ad3d-7e4423a18906)
    
![5_7](https://github.com/user-attachments/assets/4531c1d7-25ff-4309-b427-c4cfaa45b8bd)
    
![5_8](https://github.com/user-attachments/assets/27069faa-3d75-403a-b695-6988abae79e9)
    
![5_9](https://github.com/user-attachments/assets/7101e746-b1f3-406f-b8cb-c283e541f142)
    
![5_10](https://github.com/user-attachments/assets/3a7457ea-09c7-432a-9de6-b06e3e5c500a)
    
![5_11](https://github.com/user-attachments/assets/2c85858d-85e5-4e79-bc22-3c09e5edbab6)
    
![5_12](https://github.com/user-attachments/assets/5bd2fa2a-afbd-4b2a-b23c-e923bcaae3d9)

Result:

* Block Diagram :

  ![5_block](https://github.com/user-attachments/assets/939aa4d0-aec0-4541-8815-6e5bbe96664a)

* Viz Table : We can see that value of reg 14 reaches 45 after 54 cycles.

  ![5_viz](https://github.com/user-attachments/assets/ae94c074-6515-46e5-bda6-c06ab03aa536)

* Waveform:
  * CLK named as clk_adi:

    ![5_clk](https://github.com/user-attachments/assets/6473761f-9347-4f70-b8cc-4159fe318472)

  * Reset waveform :

    ![5_reset](https://github.com/user-attachments/assets/057cfe2b-9eb1-4569-b253-9b80c838f7b5)

  * Final result waveform showing gradual increase:

    ![5_xreg](https://github.com/user-attachments/assets/ab06991f-499c-41f3-8826-a963f10c97b5)

Simulation Status :

![5_sim](https://github.com/user-attachments/assets/725ff7e0-be79-4b95-b6b7-62e05fb596cc)

  </details>
</details>

<details>
  <summary>LAB 7: </summary>
  In this lab, we have to convert TLV to Verilog, as explained in the video using Sandpiper. In this we have to write a testbench for rvmyth. Also we have to use "iverilog" to simulate and use gtkwave to view the output waveforms. 
  
  After that we have to plot the following graphs using gtkwave:

  * clock signal appended with your name ("clk_adi" in my case).
  * reset signal
  * 10-bit output which shows the gradual addition of 1 to 10 or 1 to 9 (1 to 9 in my case).

For this, we have to use the following commands in the listed order:

```
$ sudo apt install make python3 python3 python3-pip git iverilog gtkwave

$ cd ~

$ sudo apt-get install python3-venv

$ python3 -m venv .venv

$ source ~/.venv/bin/activate
```

![7_1](https://github.com/user-attachments/assets/d266a19b-45dc-4151-be09-4608a0088f55)

```
$ pip3 install pyyaml click sandpiper-saas

$ sudo apt install make python python3 python3-pip git iverilog gtkwave docker.io

$ sudo chmod 666 /var/run/docker.sock

$ cd ~

$ pip3 install pyyaml click sandpiper-saas

$ cd ~

$ git clone https://github.com/manili/VSDBabySoC.git
```

![7_2](https://github.com/user-attachments/assets/b3398075-6283-4ffc-812f-818604c2051b)

```
$ cd /home/vsduser/VSDBabySoC

$ make pre_synth_sim

$ sandpiper-saas -i ./src/module/rvmyth.tlv -o rvmyth.v --bestsv --noline -p verilog --outdir ./src/module/
```

![7_3](https://github.com/user-attachments/assets/7ffafc57-d3d1-47c1-98a3-4e89579d01c8)

```
$ iverilog -o output/pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module
```

![7_4](https://github.com/user-attachments/assets/f71865b3-b0f5-46bc-ac0f-8806263ff8b4)

```
$ cd output

$ ./pre_synth_sim.out
```

![7_5](https://github.com/user-attachments/assets/6264ced7-cc22-4f0f-9772-a745b44f4ab0)

![7_6](https://github.com/user-attachments/assets/5245abc1-ed4c-4de9-bd5e-fd57112908ab)

  Following are the results (comparison between gtkwave waveforms and makerchip simulations):

  * Clock waveform (clk_adi in my case):

    ![clk_adi_7](https://github.com/user-attachments/assets/398c8fb0-ce79-4553-ad14-b9681f1d6102)
    
    ![clk_adi_6](https://github.com/user-attachments/assets/739a1441-04d6-4477-80e2-aac87324a0a8)

  * Reset signal:

    ![reset_7](https://github.com/user-attachments/assets/0cdc71c2-453e-4722-87fd-8c706f9d5500)
    
    ![reset_6](https://github.com/user-attachments/assets/37fb00ff-1427-47dd-bf6e-883076ef85f7)

  * Final output waveform:

    ![final_7](https://github.com/user-attachments/assets/2e419d22-8ff3-403e-87ec-5282e9b7c55f)

    ![final_6](https://github.com/user-attachments/assets/bd92bfdc-3b5d-4f1b-9c2f-18f8c3eda225)

  By this we can see that there is gradual increment. Both the waveforms eventually reach the value 45 (sum from 1 to 9).
</details>

<details>
  <summary>LAB 8: </summary>
In this lab, we have to first install iverilog, gtkwave, yosys and opensta on our personal machines. Then we have to download all the files from BabySoC link, and edit the vsdbabysoc top level verilog code.

Then we had to generate DAC and PLL waveform for RISC-V processor.

Firstly, we install iverilog, gtkwave, yosys, and opensta on our system.

![iverilog](https://github.com/user-attachments/assets/f8d51c63-db40-4ecd-ae7e-5a7b8b5639e3)

![yosys](https://github.com/user-attachments/assets/faa508f9-1d3e-4125-ba19-6427f2129e99)

Then, we edit the top-level code verilog code for the vsdbabysoc to achieve the desired results.

And finally, run the following commands to show and perform the functional simulation.

```
cd BabySoC_Simulation
iverilog -o ./pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module/
./pre_synth_sim.out
gtkwave pre_synth_sim.vcd
```

![gtkwave_terminal](https://github.com/user-attachments/assets/eef4446a-48e6-47ce-825b-91edadbb6a37)

Results:

Following are the waveforms generated:

![uncondensed_form](https://github.com/user-attachments/assets/68a6ca09-3dfd-4995-a675-416898c42856)

![condensed_form_graph](https://github.com/user-attachments/assets/90ec0925-fe1c-4811-9774-ca7b284cc6e2)


</details>

<details>
  <summary>LAB 9: </summary>
  <details>
  <summary>Day 1:</summary>
    
  ![day1_abc](https://github.com/user-attachments/assets/25b06e57-88b0-476b-9fed-8fdf947e79e5)

  ![day1_gtkwave_command](https://github.com/user-attachments/assets/fd0e2cda-da82-40a9-a4da-b286d6ffa7f4)

  ![day1_gtkwave](https://github.com/user-attachments/assets/6d7ab422-ee6f-449e-81f7-122adbe683fa)

  ![day1_printing_statistics](https://github.com/user-attachments/assets/ff8349e7-9da3-485a-ab27-68e4c7519f27)

  ![day1_schematic](https://github.com/user-attachments/assets/b1ed3bdb-a61a-43ef-88a3-aacafdfe6950)

  ![day1_caat_image](https://github.com/user-attachments/assets/c8c4ac4d-44a4-4744-8534-cc3c578906c9)
  
  </details>

  <details>
  <summary>Day 2: </summary>

  ![day2_vim1](https://github.com/user-attachments/assets/3c76d434-6fcc-47e7-b74e-cab3fa89882b)

  ![day2_vim2](https://github.com/user-attachments/assets/4ae9c21c-e542-4296-a645-76cb51c795a9)

  ![day2_vim3](https://github.com/user-attachments/assets/2306c15b-2d52-44c0-9e2d-680d3a933ea8)

  ![day2_vim4](https://github.com/user-attachments/assets/690abd6f-283e-41cc-a489-a1acd0260ff7)

  * Hierarchical Synthesis:

    ![day2_printstats](https://github.com/user-attachments/assets/596998a5-5b72-4e4b-9a9a-df1215327089)

    ![day2_schematic1](https://github.com/user-attachments/assets/3ac72400-999f-4617-9efe-9bcd9e2d99b0)

    ![day2_vimcode1](https://github.com/user-attachments/assets/b8428971-49ce-4ac1-8de0-a3a76ac0bc9e)

  * Flat Synthesis:

    ![day2_printstats2](https://github.com/user-attachments/assets/a780ccf7-2fa7-4da7-9d6b-6a14de16aee7)

    ![day2_schematic2](https://github.com/user-attachments/assets/7e2a38c1-df55-4113-8677-d40c4113f1a5)

    ![day2_vimcode2](https://github.com/user-attachments/assets/296435aa-e727-4a29-9ac7-9d437a773d7c)

  * Sub Module Level Synthesis:

    ![day2_printstats3](https://github.com/user-attachments/assets/492bb57e-1059-4f80-bb54-af6b3509e60a)

    ![day2_schematic3](https://github.com/user-attachments/assets/d01d15f6-766d-416d-9820-bee280567a7d)

  * Flip-Flop Design and Optimization Techniques:
    * Asynchronous Reset Flip-Flop:

      ![day2_gtkwave1](https://github.com/user-attachments/assets/9220cf8c-67ee-4a87-9127-e64c6144ca57)
      
      ![day2_printstats4](https://github.com/user-attachments/assets/789c02fb-7513-4ac5-b650-83f08bfd3c61)

      ![day2_schematic4](https://github.com/user-attachments/assets/32292694-6ab3-4bd6-be6a-f51e03fe9375)

    * Synchronous Reset Flip-Flop:
   
      ![day2_gtkwave2](https://github.com/user-attachments/assets/633de672-236a-4ee9-8f02-48eec2a782f6)

      ![day2_printstats5](https://github.com/user-attachments/assets/28fbad73-ae14-40bc-9a09-929cfe74f267)

      ![day2_schematic5](https://github.com/user-attachments/assets/8868228f-c804-412a-9f92-aadd4f423f41)

    * Asynchronous Set Flip-Flop:
   
      ![day2_gtkwave3](https://github.com/user-attachments/assets/35ee1ced-32bc-4d00-8ecc-5387e5615be7)

      ![day2_printstats6](https://github.com/user-attachments/assets/b8dcaba6-8ef2-4edc-9b8f-a707b69cdc3b)

      ![day2_schematic6](https://github.com/user-attachments/assets/7cc95f79-5ae5-4a10-bbbd-153999390bf7)

    * Design Optimizations:
   
      * Example 1: Multiplication by 2
  
        ![day2_printstats7](https://github.com/user-attachments/assets/1438b674-2b7a-420c-bc9f-d499c40bed3c)

        ![day2_schematic7](https://github.com/user-attachments/assets/f975c7e1-371f-471d-86f6-1eda456b3228)

      * Example 2: Multiplication by 8

        ![day2_printstats8](https://github.com/user-attachments/assets/6542429a-800e-413b-a0a6-8f101dadfb35)

        ![day2_schematic8](https://github.com/user-attachments/assets/73710f4a-dace-4d02-bed6-2faf415b9af9)

    </details>

    <details>
    <summary>Day 3:</summary>
    * Combinational Optmization:
      
      * Example 1: Multiplexer to AND Gate Optimization
  
        ![day3_printstat1](https://github.com/user-attachments/assets/41001244-73b4-4ba9-a7c5-04b64b108cb5)
  
        ![day3_schematic1](https://github.com/user-attachments/assets/ccdfe9e2-0553-4a8b-8bff-ee6b8eb9bc3f)
  
        ![day3_vim](https://github.com/user-attachments/assets/556bb7d6-075a-4a29-b9d6-474447388489)
  
      * Example 2: OR Gate Implementation from Multiplexer
     
        ![day3_printstat2](https://github.com/user-attachments/assets/aee556c8-f39c-4f37-bd6f-641ab9a9a85f)
  
        ![day3_schematic2](https://github.com/user-attachments/assets/e9de8162-28b9-49b1-9f47-f97d5f760166)
  
        ![day3_vim2](https://github.com/user-attachments/assets/f73a52d7-80dc-4035-9c4a-3f16680a85a3)
  
      * Example 3: Optimizing a 3-Input AND Gate
     
        ![day3_printstat3](https://github.com/user-attachments/assets/7aa6d127-471b-44ac-aec4-18a4069a94a2)
  
        ![day3_schematic3](https://github.com/user-attachments/assets/d95c04f2-f4d4-4579-a6f8-bc7d015a0ed1)
  
        ![day3_vim3](https://github.com/user-attachments/assets/f1157250-2c15-4f34-9b08-bc7f0723eb8f)
  
      * Example 4: Transforming to a 2-Input XNOR Gate
     
        ![day3_printstat4](https://github.com/user-attachments/assets/95056fd8-b65f-46a7-ad35-4a11d9c56991)
  
        ![day3_schematic4](https://github.com/user-attachments/assets/af4d6e41-9633-4244-b78f-7d9f163ac5f6)
  
        ![day3_vim4](https://github.com/user-attachments/assets/589a1971-0d5e-466b-8862-613223eca0da)
  
      * Example 5: Optimization of a Complex Multi-Module Design
     
        ![day3_printstat5](https://github.com/user-attachments/assets/ef2ae289-0327-4694-94be-ddd70b5aac97)
  
        ![day3_schematic5](https://github.com/user-attachments/assets/99044aed-a578-4eb9-a0a1-bb3cb9e7f3d4)
  
        ![day3_vim5](https://github.com/user-attachments/assets/66b1c82a-995b-4633-b7aa-8dabc14d8876)
  
      * Example 6: Design Simplified to Constant Output (Y=0)
     
        ![day3_printstat6](https://github.com/user-attachments/assets/81d0749a-6c7c-4944-b706-ad3f2ba6833d)
  
        ![day3_schematic6](https://github.com/user-attachments/assets/c78ce31b-8ad2-4f16-b826-fd8735f82f39)
  
        ![day3_vim6_1](https://github.com/user-attachments/assets/56baf2b5-d72b-4149-8f59-935e7648121c)
  
        ![day3_vim6_2](https://github.com/user-attachments/assets/024e9368-b4dd-45cb-a13e-3524350e81d3)

* Sequential Logic Optimizations:
      
  * Example 1: Constant Output Flip-Flop (Logic 1)

      ![day3_printstat7](https://github.com/user-attachments/assets/f6c08a42-c164-4275-ad25-6c841a937cc4)

      ![day3_schematic7](https://github.com/user-attachments/assets/f30b2127-931f-4e84-8133-9cd70842a1cb)

      ![day3_vim7](https://github.com/user-attachments/assets/0cf20169-6890-4f63-9072-3b51086cf5c6)

      ![day3_gtkwave1](https://github.com/user-attachments/assets/fba17cc9-4e9e-4ae1-966f-5e8c0b696a92)

  * Example 2: Constant High Flip-Flop (Hardwired 1)
 
    ![day3_printstat8](https://github.com/user-attachments/assets/70075875-366b-4241-ba4e-bebc034a607b)
 
    ![day3_schematic8](https://github.com/user-attachments/assets/9da39131-24e7-4128-83fa-8318284cf02d)
 
    ![day3_vim8](https://github.com/user-attachments/assets/b394e70f-a301-4b1c-92f7-977e49b6abed)
 
    ![day3_gtkwave2](https://github.com/user-attachments/assets/d2c40e0b-85f5-4dc2-986b-bcd6e0ba5ed7)
 
  * Example 3: DFF with Intermediate Flip-Flop
 
    ![day3_printstat9](https://github.com/user-attachments/assets/5bb29d27-a43b-4789-ac66-e5f19d03b024)
 
    ![day3_schematic9](https://github.com/user-attachments/assets/17512c40-511e-456d-ab93-2999761ca3d1)
 
    ![day3_vim9](https://github.com/user-attachments/assets/87a293ce-0262-451e-870b-e3e0254233c3)
 
    ![day3_gtkwave3](https://github.com/user-attachments/assets/1417f3f0-b6dc-470e-8e8f-aef2e2ba7243)

  * Example 4: Redundant Constant Assignment Flip-Flop
 
    ![day3_printstat10](https://github.com/user-attachments/assets/27794f33-b465-484d-b662-0608cfb9b098)
 
    ![day3_schematic10](https://github.com/user-attachments/assets/3cf649f1-7fd6-4c93-9d8c-bdc286c3541b)
 
    ![day3_vim10](https://github.com/user-attachments/assets/8294e8fe-6149-45e1-8093-434db8f02246)
 
    ![day3_gtkwave4](https://github.com/user-attachments/assets/90cd6363-5988-4c40-9e7a-1af4602bf640)

  * Example 5: Unused Flip-Flop
 
    ![day3_printstat11](https://github.com/user-attachments/assets/4d424798-95bc-4ca2-8bbd-60abee6f96e8)
 
    ![day3_schematic11](https://github.com/user-attachments/assets/c44cadec-dd9f-43de-ae99-5b9337ad9647)
 
    ![day3_vim11](https://github.com/user-attachments/assets/66c3e7b6-8ef5-474c-a7ec-ad4a873b32f3)
 
    ![day3_gtkwave5](https://github.com/user-attachments/assets/d8a9db75-5302-4088-bffd-ba08832383aa)

* Optimizing Unused Outputs in Corners

  * Example 1: Simple Counter with Unused Bits

    ![day3_printstat12](https://github.com/user-attachments/assets/0052579c-d516-4fab-8905-5758aa97ff2b)

    ![day3_schematic12](https://github.com/user-attachments/assets/b25e8603-1ad8-4799-aa10-e3955efd7cb9)

    ![day3_vim12](https://github.com/user-attachments/assets/a8572d43-1fe3-4f36-a071-e559c0efc87e)

    ![day3_gtkwave6](https://github.com/user-attachments/assets/faf82437-096a-4c04-b5ba-ac9af7a49a6b)

  * Modified Counter Logic: Reducing Unused Bits
 
    ![day3_printstat13](https://github.com/user-attachments/assets/07b42c51-7c27-4ab9-8374-c80bf8c7e171)
 
    ![day3_schematic13](https://github.com/user-attachments/assets/940ab766-ec15-4bab-bce4-d67d64068f4c)
 
    ![day3_vim13_1](https://github.com/user-attachments/assets/1094d634-c0dd-4b0f-bcb0-510384ca5e59)
 
    ![day3_vim13_2](https://github.com/user-attachments/assets/7438ab5f-614f-4fb9-986e-39d7a5c86dd9)
 
    ![day3_gtkwave7](https://github.com/user-attachments/assets/ae31a124-17f2-49c0-aa25-917f43eba722)

    </details>

    <details>
 
    <summary>Day 4:</summary> 
 
    * Example 1: Basic Ternary Mux
    
      ![day4_gtkwave1](https://github.com/user-attachments/assets/dfa58311-9083-45f3-988d-d076d9f04668)
 
      ![day4_printstat1](https://github.com/user-attachments/assets/2bb5f8cb-d88a-4547-a8cd-95c96f32296b)
 
      ![day4_schematic1](https://github.com/user-attachments/assets/a0de5a30-5389-4db9-b9fc-c9a7b3694cb3)
 
      ![day4_vim1](https://github.com/user-attachments/assets/37672440-817d-4c3d-9755-d1d1f0287cdd)
 
      Gate Level Simulation
 
        ![day4_gtkwave1_new](https://github.com/user-attachments/assets/0e98ac10-8bee-4360-b7fc-8475ec942d00)

    * Example 2: Bad MUX Example
   
      ![day4_gtkwave2](https://github.com/user-attachments/assets/3edc0a92-222e-4a9d-91db-a5a60850a1e4)

      ![day4_printstat2](https://github.com/user-attachments/assets/7e80a9c1-dce6-481e-995e-843c915ef92b)
 
      ![day4_schematic2](https://github.com/user-attachments/assets/f9eb9196-a05c-41a3-a673-7416da387c15)
 
      ![day4_vim2](https://github.com/user-attachments/assets/1f5972a8-8862-4ece-a9d6-d50e10de576f)
 
      Gate Level Simulation
 
        ![day4_gtkwave2_new](https://github.com/user-attachments/assets/24ac8408-3183-4697-95b1-dff65a7a195a)

    * Investigation of Synthesis-Simulation Mismatches for Blocking Assignments
   
      ![day4_gtkwave3](https://github.com/user-attachments/assets/177d9512-df60-457e-96fe-38128d62ae7d)

      ![day4_schematic3](https://github.com/user-attachments/assets/75bd07f6-e931-462e-a057-db378fe7611b)

      ![day4_vim3](https://github.com/user-attachments/assets/b97e6447-e0e5-485e-9e3b-8fcf62c201cb)
 
      Gate Level Simulation
 
        ![day4_gtkwave4](https://github.com/user-attachments/assets/99ed3ca7-43be-4cdb-b6b9-4d54b98924f3)


        



      
    </details>
    
</details>
